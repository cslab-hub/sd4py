window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "sd4py", "modulename": "sd4py", "type": "module", "doc": "<p>SD4Py</p>\n\n<p>This module provides functions to discover subgroups on pandas DataFrames, and visualise them. It contains the following subpackages:</p>\n\n<ul>\n<li>sd4py - Core functions to discover subgroups from a pandas DataFrame</li>\n<li>sd4py_extra - Additional visualisation functions to display and further investigate results</li>\n</ul>\n"}, {"fullname": "sd4py.sd4py", "modulename": "sd4py.sd4py", "type": "module", "doc": "<p>sd4py is a package that makes it easy to perform subgroup discovery on tabular data. It is extremely simple to use. Call the <code>sd4py.discover_subgroups()</code> function on a pandas dataframe and a collection of subgroups will be returned. </p>\n\n<p>This package provides a Python interface for using the Java application VIKAMINE. </p>\n\n<p>Subgroup discovery is based on finding patterns within some (explanatory) columns of data that then help to explain another (target) column of data. \nThe goal of the subgroup discovery process will be to understand in what circumstances the target is extreme. With a numeric target, this means finding circumstances in which the value is exceptionally high (or exceptionally low) on average.\nFor a non-numeric target, this means looking for circumstances when a particular value is especially likely to occur.\nOne of the key benefits of this approach is that the outputs are interpretable, being expressed as a readable combination of rules like (e.g.)  \"'Temperature'=high AND 'Pressure'=low\". </p>\n\n<p>The package contains a <code>discover_subgroups()</code> function that finds subgroups based on a pandas <code>DataFrame</code> and a specifed target column. The package also includes custom python objects for holding the results.</p>\n"}, {"fullname": "sd4py.sd4py.PyOntology", "modulename": "sd4py.sd4py", "qualname": "PyOntology", "type": "class", "doc": "<p>Puts data into a Java <code>Ontology</code> object for use with the underlying Java subgroup discovery application.</p>\n\n<p>It is not necessary to use this class explicitly; pandas dataframes will automatically be converted into a <code>PyOntology</code> object when passed into <code>discover_subgroups()</code>.\nHowever, if the dataset is large, and subgroup discovery will be performed multiple times, then the user may opt to convert the dataset into a <code>PyOntology</code> to pass into <code>discover_subgroups()</code> for the sake of performance.</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>The only attribute of the class is <code>ontology</code>, created during initialisation, which is bound to an <code>Ontology</code> object in the Java runtime.</strong></li>\n</ul>\n"}, {"fullname": "sd4py.sd4py.PyOntology.__init__", "modulename": "sd4py.sd4py", "qualname": "PyOntology.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, df)", "funcdef": "def"}, {"fullname": "sd4py.sd4py.PyNumericSelector", "modulename": "sd4py.sd4py", "qualname": "PyNumericSelector", "type": "class", "doc": "<p>Represents a rule to select a subset of data, which combines with other selectors to form the subgroup/pattern definition.\nThe relevant attribute name in the data is stored in <code>attribute</code>.\nThis contains a <code>numeric lower_bound</code>, <code>upper_bound</code>, plus booleans <code>include_lower_bound</code> and <code>include_upper_bound</code> to decide whether border values are included in the selection.</p>\n\n<p>Note that this is detached from the Java runtime, and so is a plain python object.</p>\n"}, {"fullname": "sd4py.sd4py.PyNumericSelector.__init__", "modulename": "sd4py.sd4py", "qualname": "PyNumericSelector.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    attribute,\n    lower_bound,\n    upper_bound,\n    include_lower_bound,\n    include_upper_bound\n)", "funcdef": "def"}, {"fullname": "sd4py.sd4py.PyNominalSelector", "modulename": "sd4py.sd4py", "qualname": "PyNominalSelector", "type": "class", "doc": "<p>Represents a rule to select a subset of data, which combines with other selectors to form the subgroup/pattern definition.\nIt indicates an attribute-value pair through <code>attribute</code> and <code>value</code>.</p>\n\n<p>Note that this is detached from the Java runtime, and so is a plain python object.</p>\n"}, {"fullname": "sd4py.sd4py.PyNominalSelector.__init__", "modulename": "sd4py.sd4py", "qualname": "PyNominalSelector.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, attribute, value)", "funcdef": "def"}, {"fullname": "sd4py.sd4py.PySubgroup", "modulename": "sd4py.sd4py", "qualname": "PySubgroup", "type": "class", "doc": "<p>Represents a subgroup in terms of its selectors, target evaluation, size and quality.</p>\n\n<p>Note that this is detached from the Java runtime, and so is a plain python object.</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>selectors</strong> (list):\nA list of <code>PySelector</code> objects representing the rules constituting the subgroup/pattern.</li>\n<li><strong>target_evaluation</strong> (float):\nThe value of the target variable for this subgroup (when evaluated against the dataset originally used for subgroup discovery).</li>\n<li><strong>size</strong> (int):\nThe number of members in this subgroup (when evaluated against the dataset originally used for subgroup discovery).</li>\n<li><strong>quality</strong> (float):\nThe quality of this subgroup (when applying the quality function to the dataset originally used for subgroup discovery).</li>\n<li><strong>target</strong> (string):\nThe name of the target column.</li>\n<li><strong>target_value</strong> (object):\nThe value of the target variable that counts as the 'positive' class.</li>\n</ul>\n"}, {"fullname": "sd4py.sd4py.PySubgroup.__init__", "modulename": "sd4py.sd4py", "qualname": "PySubgroup.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    selectors,\n    target_evaluation,\n    size,\n    quality,\n    target,\n    target_value\n)", "funcdef": "def"}, {"fullname": "sd4py.sd4py.PySubgroup.get_indices", "modulename": "sd4py.sd4py", "qualname": "PySubgroup.get_indices", "type": "function", "doc": "<p>Get the indices of rows that meet the subgroup definition for a specified dataset.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>data</strong> (pandas DataFrame):\nThe dataset in which to look for (the indices of) rows that match the subgroup definition.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>index</strong> (pandas Index):\nThe index identifying rows that meet the subgroup definition in the dataset provided.</li>\n</ul>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "sd4py.sd4py.PySubgroup.get_rows", "modulename": "sd4py.sd4py", "qualname": "PySubgroup.get_rows", "type": "function", "doc": "<p>Get the rows that meet the subgroup definition for a specified dataset.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>data</strong> (pandas DataFrame):\nThe dataset in which to look for rows that match the subgroup definition.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>rows</strong> (pandas DataFrame):\nA selection of rows in the provided dataset that meet the subgroup definition.</li>\n</ul>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "sd4py.sd4py.PySubgroupResults", "modulename": "sd4py.sd4py", "qualname": "PySubgroupResults", "type": "class", "doc": "<p>A collection of subgroups, returned as a result of performing subgroup discovery.</p>\n\n<p>Note that this is detached from the Java runtime, and so is a plain python object.</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>subgroups</strong> (list):\nA list of <code>PySubgroup</code> objects.</li>\n<li><strong>population_evaluation</strong> (float):\nThe value of the target variable across the entire dataset originally used for subgroup discovery.</li>\n<li><strong>population_size</strong> (int):\nThe number of rows in the dataset originally used for subgroup discovery.</li>\n<li><strong>target</strong> (string):\nThe name of the target column.</li>\n<li><strong>target_value</strong> (object):\nThe value of the target variable that counts as the 'positive' class.</li>\n</ul>\n"}, {"fullname": "sd4py.sd4py.PySubgroupResults.__init__", "modulename": "sd4py.sd4py", "qualname": "PySubgroupResults.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    subgroups,\n    population_evaluation,\n    population_size,\n    target,\n    target_value\n)", "funcdef": "def"}, {"fullname": "sd4py.sd4py.PySubgroupResults.to_df", "modulename": "sd4py.sd4py", "qualname": "PySubgroupResults.to_df", "type": "function", "doc": "<p>Convert the subgroups included in this object into an easy-to-read pandas dataframe for viewing.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>subgroups_df</strong> (pandas DataFrame):\nA table showing the subgroup definitions and associated important values like size, target value, and quality.</li>\n</ul>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "sd4py.sd4py.discover_subgroups", "modulename": "sd4py.sd4py", "qualname": "discover_subgroups", "type": "function", "doc": "<p>Search for interesting subgroups within a dataset.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>ontology</strong> (pandas DataFrame or PyOntology object.):\nThe data to use to peform subgroup discovery. Can be a pandas DataFrame, or a PyOntology object.</li>\n<li><strong>target</strong> (string):\nThe name of the column to be used as the target.</li>\n<li><strong>target_value</strong> (object, optional):\nThe value of the target variable that counts as the 'positive' class. Not needed for a numeric target, in which case the mean of the target variable will be used for subgroup discovery.</li>\n<li><strong>included_attributes</strong> (list, optional):\nA list of strings containing the names of columns to use. If not specified, all columns of the data will be used.</li>\n<li><strong>nbins</strong> (int, optional):\nThe number of bins to use when discretising numeric variables. Default value is 3.</li>\n<li><strong>method</strong> (string, optional):\nUsed to decide which algorithm to use. Must be one of Beam-Search <code>beam</code>, BSD <code>bsd</code>, SD-Map <code>sdmap</code>, SD-Map enabling internal disjunctions <code>sdmap-dis</code>. The default is <code>sdmap</code>.</li>\n<li><strong>qf</strong> (string, optional):\nUsed to decide which algorithm to use. Must be one of Adjusted Residuals <code>ares</code>, Binomial Test <code>bin</code>, Chi-Square Test <code>chi2</code>, Gain <code>gain</code>, Lift <code>lift</code>, Piatetsky-Shapiro <code>ps</code>, Relative Gain <code>relgain</code>, Weighted Relative Accuracy <code>wracc</code>, Wilcoxon-Mann-Whitney Rank <code>wmw</code>, Area-Under-Curve <code>auc</code>. The default is qf = <code>ps</code>.</li>\n<li><strong>k</strong> (int, optional):\nMaximum number (top-k) of patterns to discover, i.e., the best k patterns according to the selected quality function. The default is 20.</li>\n<li><strong>minqual</strong> (float, optional):\nThe minimal quality. Defaults to 0, meaning there is no minimum.</li>\n<li><strong>minsize</strong> (int, optional):\nThe minimum size of a subgroup in order for it to be included in the results. Defaults to 0, meaning there is no minimum.</li>\n<li><strong>mintp</strong> (int, optional):\nThe minimum number of true positives in a subgroup (relevant for binary target concepts only). Defaults to 0, meaning there is no minimum</li>\n<li><strong>max_selectors</strong> (int, optional):\nThe maximum number of selectors/rules included in a subgroup. The default is 3.</li>\n<li><strong>ignore_defaults</strong> (bool, optional):\nIf set to True , the values in the first row of data will be considered \u2018default values\u2019, and the same values will be ignored when searching for subgroups. Defaults to False.</li>\n<li><strong>filter_irrelevant</strong> (bool, optional):\nWhether irrelevant patterns are filtered out. Note that this negatively impacts performance. Defaults to False.</li>\n<li><strong>postfilter</strong> (string, optional):\nWhich post-processing filter is applied.\nCan be one of:\n<ul>\n<li>Minimum Improvement (Global) <code>min_improve_global</code>, which checks the patterns against all possible generalisations;</li>\n<li>Minimum Improvement (Pattern Set) <code>min_improve_set</code>, checks the patterns against all their generalisations in the result set,</li>\n<li>Relevancy Filter <code>relevancy</code>, removes patterns that are strictly irrelevant,</li>\n<li>Significant Improvement (Global) <code>sig_improve_global</code>, removes patterns that do not significantly improve (default 0.01 level, can be overridden with postfilter_param) with respect to all their possible generalizations,</li>\n<li>Significant Improvement (Set) <code>sig_improve_set</code>, removes patterns that do not significantly improve (default 0.01 level, can be overridden with postfilter_param) with respect to all generalizations in the result set,</li>\n<li>Weighted Covering <code>weighted_covering</code>, performs weighted covering on the data in order to select a covering set of subgroups while reducing the overlap on the data.\nBy default, no postfilter is set, i.e., postfilter = \"\".</li>\n</ul></li>\n<li><strong>postfilter_param</strong> (float, optional):\nProvides the corresponding parameter value for the filtering chosen in postfilter. Must be provided for most postfiltering types</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>subgroups</strong> (PySubgroupResults):\nThe discovered subgroups.</li>\n</ul>\n", "signature": "(\n    ontology,\n    target,\n    target_value=None,\n    included_attributes=None,\n    nbins=3,\n    method='sdmap',\n    qf='ps',\n    k=20,\n    minqual=0,\n    minsize=0,\n    mintp=0,\n    max_selectors=3,\n    ignore_defaults=False,\n    filter_irrelevant=False,\n    postfilter='',\n    postfilter_param=0.0\n)", "funcdef": "def"}, {"fullname": "sd4py.sd4py_extra", "modulename": "sd4py.sd4py_extra", "type": "module", "doc": "<p></p>\n"}, {"fullname": "sd4py.sd4py_extra.bootstrapping", "modulename": "sd4py.sd4py_extra", "qualname": "bootstrapping", "type": "function", "doc": "<p>Provides some estimate of variability for subgroups. Multiple samples (with replacement) are drawn from the data,\nand subgroups are evaluated for each sample (using the metric_function).\nThe aggregation function is then applied to this data (e.g. to select 0.05 and 0.95 quantiles) to give a final description for each subgroup.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>subgroups</strong> (PySubgroup object or list of PySubgroup objects):\nThe subgroup(s) for which to perform bootstrapping.</li>\n<li><strong>data</strong> (DataFrame):\nThe data to be used to evaluate the subgroups; bootstrapping works by drawing samples from this data using replacement.</li>\n<li><strong>metric_function</strong> (function):\nThe function to use to evaluate the how well the subgroup is working on an individual sample. Must have the following parameters: (sample, subgroup_sample), where <code>sample</code> is a sample of the data, and <code>subgroup_sample</code> is the same but filtered to only include subgroup members.</li>\n<li><strong>aggregation_function</strong> (function, optional):\nUsed to aggregate across the samples. If not provided, the full list of scores (calculated by metric_function) over all the samples for each subgroup will be returned.</li>\n<li><strong>ignore_defaults</strong> (boolean, optional):\nIf True, then the first row in data will be treated as containing 'default values' to be ignored in the processing.</li>\n<li><strong>number_simulations</strong> (int, optional):\nThe number of samples to use.</li>\n<li><strong>frac</strong> (float, optional):\nThe size of each sample as a proportion of the length of data. Can be reduced to decrease computational cost.</li>\n<li><strong>replace</strong> (boolean, optional):\nSet to False to override the default sampling with replacement strategy.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>results</strong>: A dict with subgroup names as keys and bootstrapping results as values, or, when using only one subgroup, just the bootstrapping results.</li>\n<li><strong>aggregation</strong>: A dict with subgroup names as keys and aggregated results as values (or an empty dict if there is no aggregation function), or when using only one subgroup, just the aggregation (or None if there is no aggregation function).</li>\n</ul>\n", "signature": "(\n    subgroups,\n    data,\n    metric_function,\n    aggregation_function=None,\n    ignore_defaults=False,\n    number_simulations=100,\n    frac=0.3333333333333333,\n    replace=True\n)", "funcdef": "def"}, {"fullname": "sd4py.sd4py_extra.confidence_intervals", "modulename": "sd4py.sd4py_extra", "qualname": "confidence_intervals", "type": "function", "doc": "<p>Provides some estimate of variability of the target value for subgroups. Uses bootstrapping to achieve this.\nThe target value and the size of each subgroup is calculated across 100 samples of the data. The 0.05 and 0.95 quantiles are returned per subgroup.\nFor numeric target variables, the mean within subgroup members is used; for nominal targets, the proportion of subgroup members belonging to the 'positive' class is used.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>subgroups</strong> (list of PySubgroup objects):\nThe subgroup(s) for which to estimate confidence intervals.</li>\n<li><strong>data</strong> (DataFrame):\nThe data to be used to evaluate the subgroups; bootstrapping works by drawing samples from this data using replacement.</li>\n<li><strong>ignore_defaults</strong> (boolean, optional):\nIf True, then the first row in data will be treated as containing 'default values' to be ignored in the processing.</li>\n<li><strong>number_simulations</strong> (int, optional):\nThe number of samples to use.</li>\n<li><strong>frac</strong> (float, optional):\nThe size of each sample as a proportion of the length of data. Can be reduced to decrease computational cost.</li>\n<li><strong>replace</strong> (boolean, optional):\nSet to False to override the default sampling with replacement strategy.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>bootstrapping_results</strong> (dict):\nA dict with subgroup names as keys and bootstrapping results as values, or, when using only one subgroup, just the bootstrapping results.</li>\n<li><strong>confidence_intervals</strong> (DataFrame):\nA DataFrame with the estimated confidence intervals, indexed by subgroup name.</li>\n</ul>\n", "signature": "(\n    subgroups,\n    data,\n    ignore_defaults=False,\n    number_simulations=100,\n    frac=0.3333333333333333,\n    replace=True\n)", "funcdef": "def"}, {"fullname": "sd4py.sd4py_extra.confidence_intervals_to_boxplots", "modulename": "sd4py.sd4py_extra", "qualname": "confidence_intervals_to_boxplots", "type": "function", "doc": "<p>Takes the outputs of the <code>confidence_intervals</code> function and creates a boxplot showing the distribution of the target value,\nwith the width of boxes indicating the relative sizes of the subgroups on average.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><p><strong>bootstrapping_results</strong> (dict of lists, or list of lists):\nThe first output from confidence_intervals() is a dictionary, and can be passed directly into this parameter.\nThe subgroups will be sorted in order to ensure a consistent display order.\nIf this approach is taken, then the `labels' parameter should not be provided.</p>\n\n<p>Alternatively, a list with the results for multiple bootstrapping trials can be provided.\nIf this approach is taken, then the corresponding subgroup labels should also be provided in the `labels' parameter.\nThis approach offers the flexibility to choose which order the subgroups appear in.</p></li>\n<li><strong>labels</strong> (list):\nThe label to use for each subgroup.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>fig</strong> (Figure):\nThe matplotlib Figure of the boxplots</li>\n</ul>\n", "signature": "(bootstrapping_results, labels=None)", "funcdef": "def"}, {"fullname": "sd4py.sd4py_extra.confidence_precision_recall_f1", "modulename": "sd4py.sd4py_extra", "qualname": "confidence_precision_recall_f1", "type": "function", "doc": "<p>Used to provide an estimate of how variable the performance of each subgroup is.\nApplies to nominal variables, where the precision, recall and $F_1$ score are used to quantify how well a subgroup performs.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>subgroups</strong> (list of PySubgroup objects):\nThe subgroup(s) for which to estimate confidence intervals.</li>\n<li><strong>data</strong> (DataFrame):\nThe data to be used to evaluate the subgroups; bootstrapping works by drawing samples from this data using replacement.</li>\n<li><strong>ignore_defaults</strong> (boolean, optional):\nIf True, then the first row in data will be treated as containing 'default values' to be ignored in the processing.</li>\n<li><strong>number_simulations</strong> (int, optional):\nThe number of samples to use.</li>\n<li><strong>frac</strong> (float, optional):\nThe size of each sample as a proportion of the length of data. Can be reduced to decrease computational cost.</li>\n<li><strong>replace</strong> (boolean, optional):\nSet to False to override the default sampling with replacement strategy.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>bootstrapping_results</strong> (dict):\nA dict with subgroup names as keys and bootstrapping results as values, or, when using only one subgroup, just the bootstrapping results.</li>\n<li><strong>precision_recall_f1</strong> (DataFrame):\nA DataFrame with the estimated confidence intervals (0.05 and 0.95 quantiles from bootstrapping) on each of precision, recall and $F_1$, indexed by subgroup name.</li>\n</ul>\n", "signature": "(\n    subgroups,\n    data,\n    ignore_defaults=False,\n    number_simulations=100,\n    frac=0.3333333333333333,\n    replace=True\n)", "funcdef": "def"}, {"fullname": "sd4py.sd4py_extra.corrected_hedges_g", "modulename": "sd4py.sd4py_extra", "qualname": "corrected_hedges_g", "type": "function", "doc": "<p>Estimates the effect size between two samples of a numeric variable.\nThis is the corrected Hedge's G; see <a href=\"https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/hedgeg.htm\">https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/hedgeg.htm</a>.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>sample1</strong> (array):\nThe first sample of values.</li>\n<li><strong>sample2</strong> (array):\nThe second sample of values.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>corrected_hedges_g</strong> (float):\nThe estimated effect size.</li>\n</ul>\n", "signature": "(sample1, sample2)", "funcdef": "def"}, {"fullname": "sd4py.sd4py_extra.confidence_hedges_g", "modulename": "sd4py.sd4py_extra", "qualname": "confidence_hedges_g", "type": "function", "doc": "<p>Used to provide an estimate of the effect size for different subgroups when the target variable is numeric.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>subgroups</strong> (list of PySubgroup objects):\nThe subgroup(s) for which to estimate confidence intervals.</li>\n<li><strong>data</strong> (DataFrame):\nThe data to be used to evaluate the subgroups; bootstrapping works by drawing samples from this data using replacement.</li>\n<li><strong>target</strong> (string):\nThe name of the target variable.</li>\n<li><strong>value</strong> (object, optional):\nFor nominal target variables only. The value of the target variable that counts as the 'positive' class.</li>\n<li><strong>ignore_defaults</strong> (boolean, optional):\nIf True, then the first row in data will be treated as containing 'default values' to be ignored in the processing.</li>\n<li><strong>number_simulations</strong> (int, optional):\nThe number of samples to use.</li>\n<li><strong>frac</strong> (float, optional):\nThe size of each sample as a proportion of the length of data. Can be reduced to decrease computational cost.</li>\n<li><strong>replace</strong> (boolean, optional):\nSet to False to override the default sampling with replacement strategy.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>bootstrapping_results</strong> (dict):\nA dict with subgroup names as keys and bootstrapping results as values, or, when using only one subgroup, just the bootstrapping results.</li>\n<li><strong>confidence_hedges_g</strong> (DataFrame):\nA DataFrame with the estimated confidence intervals (0.05 and 0.95 quantiles from bootstrapping) on the effect size, indexed by subgroup name.</li>\n</ul>\n", "signature": "(\n    subgroups,\n    data,\n    ignore_defaults=False,\n    number_simulations=100,\n    frac=0.3333333333333333,\n    replace=True\n)", "funcdef": "def"}, {"fullname": "sd4py.sd4py_extra.odds_ratio_ci", "modulename": "sd4py.sd4py_extra", "qualname": "odds_ratio_ci", "type": "function", "doc": "<p>Estimates the effect size between two samples of a binary nominal variable.\nThis is the odds ratio, which allows us to estimate confidence intervals directly from the confusion matrix.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>sample1</strong> (array):\nThe first sample of values.</li>\n<li><strong>sample2</strong> (array):\nThe second sample of values.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>odds_ratio</strong> (float):\nThe estimated effect size.</li>\n<li><strong>lower</strong> (float):\nLower confidence interval on the estimated effect size.</li>\n<li><strong>upper</strong> (float):\nUpper confidence interval on the estimated effect size.</li>\n</ul>\n", "signature": "(sample1, sample2)", "funcdef": "def"}, {"fullname": "sd4py.sd4py_extra.find_interesting_columns", "modulename": "sd4py.sd4py_extra", "qualname": "find_interesting_columns", "type": "function", "doc": "<p>Makes it easier to find 'interesting' columns for particular subgroup by returning the estimated effect size for each variable in the dataset\n(i.e., if a variable has a large effect size then the subgroup is extreme with respect to that variable).\nProvides both interesting numeric and interesting nominal columns.\nCorrected Hedge's G is used to estimate effect size on numeric variables, and the odds ratio (and its confidence intervals) is used for nominal variables.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>subgroup</strong> (PySubgroup):\nThe subgroup for which to find interesting columns.</li>\n<li><strong>data</strong> (DataFrame):\nThe data to be used to evaluate the subgroups; bootstrapping works by drawing samples from this data using replacement.</li>\n<li><strong>use_complement</strong> (boolean, optional):\nIf True, subgroup members will be compared to non-subgroup members. Otherwise, subgroup members will be compared to the full dataset (including subgroup members).</li>\n<li><strong>ignore_defaults</strong> (boolean, optional):\nIf True, then the first row in data will be treated as containing 'default values' to be ignored in the processing.</li>\n<li><strong>columns_to_ignore</strong> (list, optional):\nA list of columns to ignore, for example these could be the target variable and/or selector variables since they are already known to be interesting.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>numeric_columns</strong> (dict):\nA dictionary with variable names as keys and estimated effect sizes as values.</li>\n<li><strong>nominal_columns</strong> (dict):\nA dictionary with variable names as keys and estimated effect sizes as values, for nominal variables.</li>\n</ul>\n", "signature": "(\n    subgroup,\n    data,\n    use_complement=True,\n    ignore_defaults=False,\n    columns_to_ignore=[]\n)", "funcdef": "def"}, {"fullname": "sd4py.sd4py_extra.most_interesting_columns", "modulename": "sd4py.sd4py_extra", "qualname": "most_interesting_columns", "type": "function", "doc": "<p>To support visualisation of a single subgroup, uses the <code>find_interesting_columns</code> function to pick the 10 most numeric and 10 most interesting nominal values for a subgroup.\nCorrected Hedge's G is used to estimate effect size on numeric variables, and lower confidence on the odds ratio is used for nominal variables.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>subgroup</strong> (PySubgroup):\nThe subgroup for which to find interesting columns.</li>\n<li><strong>data</strong> (DataFrame):\nThe data to be used to evaluate the subgroups; bootstrapping works by drawing samples from this data using replacement.</li>\n<li><strong>columns_to_ignore</strong> (list, optional):\nA list of columns to ignore, for example these could be the target variable and/or selector variables since they are already known to be interesting.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>most_interesting_numeric</strong> (DataFrame):\nA pandas DataFrame with variable names as index and estimated effect sizes as values.</li>\n<li><strong>most_interesting_nominal</strong> (DataFrame):\nA pandas DataFrame with variable names as index and estimated effect sizes as values, for nominal variables.</li>\n</ul>\n", "signature": "(subgroup, data, columns_to_ignore=[])", "funcdef": "def"}, {"fullname": "sd4py.sd4py_extra.radar_plot", "modulename": "sd4py.sd4py_extra", "qualname": "radar_plot", "type": "function", "doc": "<p>Creates a custom radar plot, where axis names and units can vary. Note that radar plots are poorly-supported by matplotlib and things like tight_layout will not work.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>data</strong> (DataFrame):\nA dataframe where columns are variables and rows are the groups (each group will become a polygon).</li>\n<li><strong>prop_scale</strong> (float, optional):\nUsed to control the size of the innermost circle (where axes begin) compared to the rest of the plot.</li>\n<li><strong>subplot</strong> (int, optional):\nUsed to determine which subplot to draw the radar plot onto.</li>\n<li><strong>text_size</strong> (int, optional):\nUsed to modify the text size of axis labels.</li>\n<li><strong>axis_padding</strong> (int, optional):\nUsed to modify the padding around axis names (to prevent them overlapping with axis tick labels). Modified by position, so more horizontal axes get more padding (since the names are more likely to overlap with the ticks).</li>\n<li><strong>ymins</strong> (list, optional):\nUsed to set the beginning of each axis</li>\n<li><strong>ymaxes</strong> (list, optional):\nUsed to set the end of each axis</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>ax</strong> (Axis):\nThe matplotlib Axis of the radar plot</li>\n</ul>\n", "signature": "(\n    data,\n    prop_scale=3,\n    subplot=111,\n    text_size=10,\n    axis_padding=15,\n    ymins=None,\n    ymaxes=None\n)", "funcdef": "def"}, {"fullname": "sd4py.sd4py_extra.subgroup_overview", "modulename": "sd4py.sd4py_extra", "qualname": "subgroup_overview", "type": "function", "doc": "<p>Creates a four-panel matplotlib visualisation for a single subgroup.\nFrom left to right, top to bottom, this shows:\n(i) the distribution of target values for the subgroup and its complement,\n(ii) the selector variable average values,\n(iii) average values for other numeric variables, and\n(iv) relative frequency of certain (variable, value) pairs for other nominal variables.}\nNote that radar plots are poorly-supported by matplotlib and things like tight_layout will not work.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>subgroup</strong> (PySubgroup):\nThe subgroup to be visualised.</li>\n<li><strong>selection_data</strong> (DataFrame):\nThe subgroup will be applied to this data, to select subgroup members. From this, the most interesting columns to visualise will be chosen. If visualisation_data is not provided, this will also be the data used to compute the values that are visualised.</li>\n<li><strong>visualisation_data</strong> (DataFrame):\nIf desired, a second dataset can be used to provide the data that is visualised (but not used to select the 'most interesting columns').</li>\n<li><strong>use_complement</strong> (boolean, optional):\nIf True, subgroup members will be compared to non-subgroup members. Otherwise, subgroup members will be compared to the full dataset (including subgroup members).</li>\n<li><strong>figsize</strong> (tuple):\nThe size in inches of the figure.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>fig</strong> (Figure):\nThe matplotlib Figure of the subgroup overview.</li>\n</ul>\n", "signature": "(\n    subgroup,\n    selection_data,\n    visualisation_data=None,\n    use_complement=True,\n    axis_padding=15,\n    figsize=(16, 15)\n)", "funcdef": "def"}, {"fullname": "sd4py.sd4py_extra.jaccard_visualisation", "modulename": "sd4py.sd4py_extra", "qualname": "jaccard_visualisation", "type": "function", "doc": "<p>Shows the similarity between a selection of subgroups. Uses the Jaccard similarity between each pair of subgroups to construct edges in a network diagram.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>subgroups</strong> (list of PySubgroup objects):\nThe subgroups to visualise.</li>\n<li><strong>data</strong> (DataFrame):\nThe data to be used to evaluate the similarity between pairs of subgroups.</li>\n<li><strong>minimum_jaccard</strong> (float):\nAn edge will only be drawn between two subgroups if their Jaccard similarity is above this value.</li>\n<li><strong>labels</strong> (list):\nThe label to use for each subgroup.</li>\n<li><strong>margins</strong> (float):\nThe size of the margins to add to the image. Increasing this can help when labels are 'cut off' at the edges.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>fig</strong> (Figure):\nThe matplotlib Figure of the boxplots</li>\n</ul>\n", "signature": "(subgroups, data, minimum_jaccard=0, labels=None, margins=0.2)", "funcdef": "def"}, {"fullname": "sd4py.sd4py_extra.timeseries_pad", "modulename": "sd4py.sd4py_extra", "qualname": "timeseries_pad", "type": "function", "doc": "<p>Helper function to pad timeseries that are of different lengths so that they are all the same length. Inputs can be Series or DataFrame objects.\nNote that the original index of each timeseries will be dropped. Returns the padded timeseries as a list.</p>\n", "signature": "(*series)", "funcdef": "def"}, {"fullname": "sd4py.sd4py_extra.subgroup_background_rectangle", "modulename": "sd4py.sd4py_extra", "qualname": "subgroup_background_rectangle", "type": "function", "doc": "<p>Helper function to draw background rectangles on a matplotlib plot to show when subgroup members have occurred over time.</p>\n", "signature": "(ax, subgroup, features, window_size)", "funcdef": "def"}, {"fullname": "sd4py.sd4py_extra.time_plot", "modulename": "sd4py.sd4py_extra", "qualname": "time_plot", "type": "function", "doc": "<p>Suitable when subgroup discovery was used to analyse windows of timeseries.\nShows multiple variables over time, and which windows of the time correspond to subgroup members (from data in the format originally used to discover subgroups).\nWindows that are subgroup members are represented by red rectangles in the background.\nAn arbitrary number of other variables are also visualised, and they can have a different sampling frequency to the data originally used to discover subgroups.\nIn summary, this shows how multiple variables progress over time, inside and outside of windows that are subgroup members.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>subgroup</strong> (PySubgroup object):\nThe subgroup to visualise.</li>\n<li><strong>features</strong> (DataFrame):\nThe data to be used to determine which windows of time are subgroup members. Should be (a subselection of) the data used first to discover subgroups.</li>\n<li><strong>n objects containing timeseries</strong> (Series or DataFrame objects):\nMultiple arguments can be passed; each one should be a Series or DataFrame object with the same sampling frequency and duration as each other.</li>\n<li><strong>timestep_delta</strong> (Timedelta):\nUsed to label the x-axis. Should be the Timedelta corresponding to one step in the x direction.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>fig</strong> (Figure):\nThe matplotlib Figure showing multiple variables over time.</li>\n</ul>\n", "signature": "(subgroup, features, *series, window_size, use_start=False)", "funcdef": "def"}, {"fullname": "sd4py.sd4py_extra.first_k_non_overlapping", "modulename": "sd4py.sd4py_extra", "qualname": "first_k_non_overlapping", "type": "function", "doc": "<p>Finds the first k subgroups that do not overlap (i.e., do not have a Jaccard similarity above the threshold) with earlier subgroups. The orderring of the subgroups is of course important for determining the results.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>data</strong> (DataFrame):\nData with which to evaluate the overlap between subgroups.</li>\n<li><strong>subgroups</strong> (PySubgroupResults or list):\nThe subgroups.</li>\n<li><strong>jaccard_threshold</strong> (float):\nThe threshold for the Jaccard similarity that decides if a subgroup is overlapping with any subgroups already processed. The results will all have a Jaccard similarity with each other that is lower than this threshold.</li>\n<li><strong>k</strong> (int):\nHow many subgroups to look for.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>non_overlapping</strong> (PySubgroupResults or list):\nA PySubgroupResults object or list (whichever was passaed as an argument to <code>subgroups</code>) containing the first k subgroups where the Jaccard similarity between them is below the threshold provided.</li>\n</ul>\n", "signature": "(data, subgroups, jaccard_threshold, k=10)", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();